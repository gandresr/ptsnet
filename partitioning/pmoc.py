
import wntr
import networkx as nx 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from numba import njit 

from time import time
import subprocess

# Temporal
import enum

class MOC_simulation:
    # Enumerators

    class Node(enum.Enum):
        node_type = 0 # {none, junction, reservoir, valve_a, valve_b}
        in_nodes_id = 1
        out_nodes_id = 2
        results_id = 3
        pipe_id = 4
        bc_id = 5
        processor = 6
        is_ghost = 7
  
    class Pipe(enum.Enum):
        node_a = 0
        node_b = 1
        diameter = 2
        area = 3
        wavespeed = 4
        ffactor = 5
        length = 6

    class Valve(enum.Enum):
        curve_id = 0
        node_a = 1
        node_b = 2
        setting_id = 3
      
    class node_type(enum.Enum):
        none = 0
        reservoir = 1
        junction = 2
        end = 3
        valve_a = 4
        valve_b = 5

    '''
    Here all the tables and properties required to
    run a MOC simulation are defined. Tables for
    simulations in parallel are created
    '''
    def __init__(self, network, T):
        '''
        Requires an MOC_network
        T: total time steps
        '''
        self.moc_network = network
        # a[a[:,self.Node.processor.value].argsort()] - Sort by processor
        self.nodes = np.zeros((len(network.mesh), len(self.Node)), dtype = int)
        self.pipes = np.zeros((network.wn.num_pipes, len(self.Pipe)), dtype = int)
        self.valves = np.zeros((network.wn.num_valves, len(self.Valve)), dtype = int)
        
        # Simulation results
        self.steady_state_sim = wntr.sim.EpanetSimulator(network.wn).run_sim()
        self.flow_results = None # np.zeros(T, len(network.mesh))
        self.head_results = None # np.zeros(T, len(network.mesh))

    def define_nodes(self):
        '''
        In the meantime, valves are not valid in general junctions
        '''
        for node, idx in self.moc_network.node_ids.items():
            # Remember that mesh is an undirected networkx Graph
            neighbors = list(self.moc_network.mesh.neighbors(node))
            if node in self.moc_network.wn.reservoir_name_list:
                # Check if node is reservoir node
                self.nodes[idx, self.Node.node_type.value] = self.node_type.reservoir.value
            # Check if the node belongs to a valve
            if self.nodes[idx, self.Node.node_type.value] == self.node_type.none.value: # Type not defined yet
                for valve in self.moc_network.valve_ids:
                    start = self.moc_network.wn.get_link(valve).start_node_name
                    end = self.moc_network.wn.get_link(valve).end_node_name
                    if node == start:
                        self.nodes[idx, self.Node.node_type.value] = self.node_type.valve_a.value
                        break
                    elif node == end:
                        self.nodes[idx, self.Node.node_type.value] = self.node_type.valve_b.value
                        break
            if self.nodes[idx, self.Node.node_type.value] == self.node_type.none.value: # Type not defined yet
                if len(neighbors) > 1:
                    # Node is considered a junction if there is more than one pipe attached to it is not a valve or reservoir
                    self.nodes[idx, self.Node.node_type.value] = self.node_type.junction.value
                
                
    # def define_initial_conditions(self):
    #     for i, node in enumerate(self.network.node_ids):
    #         if '.' in node: # interior points
    #             labels = node.split('.') # [n1, k, n2]
    #             n1 = labels[0]
    #             n2 = labels[2]
    #             k = abs(int(labels[1]))
    #             p = self.network.get_pipe_name(n1, n2)
                
    #             head_1 = float(self.steady_state_sim.node['head'][n2])
    #             head_2 = float(self.steady_state_sim.node['head'][n1])
    #             hl = head_1 - head_2
    #             L = self.network.wn.get_link(p).length
    #             dx = k * L / self.network.segments[p]
    #             self.H0[i] = head_1 - (hl*(1 - dx/L))
    #             self.Q0[i] = float(self.steady_state_sim.link['flowrate'][p])
    #         else: # Junctions
    #             self.H0[i] = float(self.steady_state_sim.node['head'][node])
    #             self.Q0[i] = float(self.steady_state_sim.node['demand'][node])

class MOC_network:
    def __init__(self, input_file):
        '''
        * The network graph is generated by WNTR
        * The MOC_network is a segmented network that includes 
            new nodes between pipes which are denominated interior points
        * The nodes in the network graph are denominated junctions
        '''
        self.fname = input_file[:input_file.find('.inp')]
        self.wn = wntr.network.WaterNetworkModel(input_file)
        self.network = self.wn.get_graph()
        self.mesh = None
        self.wavespeeds = {}
        self.dt = None
        
        # Segments are only defined for pipes
        self.segments = self.wn.query_link_attribute('length')
        
        # Ids for nodes, pipes, and valves
        self.node_ids = {}
        self.pipe_ids = {}
        self.valve_ids = {}
                
        self.partition = None
        self.separator = None
   
    def define_wavespeeds(self, default_wavespeed = 1200, wavespeed_file = None):
        if wavespeed_file:
            '''
            CSV file only
            '''
            f = open(wavespeed_file).read().split('\n')
            for p, a_p in map(lambda x : x.split(','), f):
                self.wavespeeds[p] = float(a_p)
        else:
            for p, data in self.wn.links():
                if data.link_type == 'Pipe':
                    self.wavespeeds[p] = default_wavespeed

    def define_segments(self, dt):
        # Get the maximum time steps for each pipe
        for p in self.segments:
            self.segments[p] /= self.wavespeeds[p]
        
        # Maximum dt in the system to capture waves in all pipes
        max_dt = self.segments[min(self.segments, key=self.segments.get)]

        # Desired dt < max_dt ?
        t_step = min(dt, max_dt)
        self.dt = t_step

        # The number of segments is defined
        for p in self.segments:
            self.segments[p] /= t_step
            # The wavespeed is adjusted to compensate the truncation error
            e = int(self.segments[p])-self.segments[p] # truncation error
            self.wavespeeds[p] = self.wavespeeds[p]/(1 + e/self.segments[p])
            self.segments[p] = int(self.segments[p])

    def define_mesh(self):
        '''
        This function should be called only after defining the segments
        for each pipe in the network
        '''

        G = self.network
        
        # The segmented MOC-mesh graph is generated
        self.mesh = nx.Graph() 
        
        # The MOC-mesh graph will be traversed from a boundary node
        #   Because of the nature of the WDS it is always guaranteed
        #   to have a boundary node in the model.
        boundary_node = None

        # parfor
        # nb : Node at the beginning of the edge
        # ne : Node at the end of the edge
        for i, nb in enumerate(G):
            # A boundary node is chosen
            if not boundary_node:
                if G.degree(nb) == 1:
                    boundary_node = nb
            
            for neighbor in G[nb]:
                for p in G[nb][neighbor]:
                    n1 = nb
                    link = self.wn.get_link(p)
                    if link.link_type == 'Pipe':
                        s_p = self.segments[p] # segments in p
                    elif link.link_type == 'Valve':
                        s_p = 0

                    # interior points are created (ni)
                    for j in range(s_p-1):
                        # interior points labeled with k \in {-s_p, 1} are 
                        #   ghost nodes

                        k = -j if j == s_p-2 else j

                        # 'initial_node.k.end_node'
                        ni = nb + '.' + str(k) + '.' + neighbor
                        self.mesh.add_edge(n1, ni)
                        n1 = ni

                    self.mesh.add_edge(n1, neighbor)
        
        # parfor
        self._define_ids()

    def _define_ids(self):
        for i, node in enumerate(self.mesh):
            self.node_ids[node] = i
        i = 0; j = 0
        for (n1, n2) in self.network.edges():
            p = self.get_pipe_name(n1, n2)
            if self.wn.get_link(p).link_type == 'Pipe':
                self.pipe_ids[p] = i
                i += 1
            elif self.wn.get_link(p).link_type == 'Valve':
                self.valve_ids[p] = j
                j += 1

    def write_mesh(self):
        '''
        This function should only be called after defining the mesh
        '''
        G = self.mesh
        # Network is stored in METIS format
        if G:
            with open(self.fname + '.graph', 'w') as f:
                f.write("%d %d\n" % (len(G), len(G.edges())))
                for i, node in enumerate(self.node_ids):
                    fline = "" # file content
                    for neighbor in G[node]:
                        fline += "%d " % (self.node_ids[neighbor] + 1)
                    fline += '\n'
                    f.write(fline)

    def define_partitions(self, k):
        script = './parHIP/kaffpa'
        subprocess.call([
            script, self.fname + '.graph', 
            '--k=' + str(k), 
            '--preconfiguration=strong', 
            '--output_filename=partitionings/p%d' % k])

        if k == 2:
            script = './parHIP/node_separator'
        else:
            script = './parHIP/partition_to_vertex_separator'

        subprocess.call([
            script, self.fname + '.graph', 
            '--k=' + str(k), 
            '--input_partition=partitionings/p%d' % k, 
            '--output_filename=partitionings/s%d' % k])

        self.partition = np.loadtxt('partitionings/p%d' % k, dtype=int)
        self.separator = np.loadtxt('partitionings/s%d' % k, dtype=int)
        
    def get_processor(self, node):
        return self.partition[self.node_ids[node]]
    
    def get_pipe_name(self, n1, n2):
        if n2 not in self.network[n1]:
            return None
        for p in self.network[n1][n2]:
            return p


class Wall_clock:
    def __init__(self):
        self.clk = time()
    
    def tic(self):
        self.clk = time()
    
    def toc(self):
        print('Elapsed time: %f seconds' % (time() - self.clk))